# LangGraph Thread Management: Application-Generated Thread IDs & Singleton Checkpointer

**Guiding Principles:**

1.  **Application-Generated `thread_id`:** The application (frontend or backend service callable by the frontend) MUST generate a unique `thread_id` for each new proposal/conversation instance. This `thread_id` is then provided to the LangGraph server via the SDK's `configurable` object for all stateful interactions when a checkpointer is in use.
2.  **Singleton Checkpointer for LangGraph Server:** The LangGraph server (running on port 2024) will initialize its `PostgresSaver` checkpointer (and the underlying database pool) as a singleton resource. The `PostgresSaver.setup()` method will be called **only once** during the LangGraph server's lifecycle to prepare the database.

**Overall System Flow:**

1.  **New Proposal Initiation (Frontend):**
    - User indicates intent to start a new proposal for a specific `rfpId`.
    - Frontend generates a new, unique `thread_id` (e.g., UUID).
    - Frontend calls an Express backend API endpoint (port 3001) to record the association: `(userId, rfpId, newly_generated_thread_id, optional_proposal_title)`.
    - Frontend proceeds to interact with the LangGraph server (port 2024), consistently passing this `newly_generated_thread_id` in `configurable: { thread_id: ... }` for all SDK calls related to this proposal.
2.  **LangGraph Server (Port 2024):**
    - Upon startup, its graph compilation process (via `createProposalGenerationGraph`) initializes a singleton `PostgresSaver` checkpointer, ensuring `setup()` is called once.
    - Receives SDK calls from the frontend with the application-provided `thread_id`.
    - Uses its configured singleton `PostgresSaver` checkpointer to create a new checkpoint (if `thread_id` is new to it) or load an existing one.
    - Manages all state and history against this provided `thread_id`.
3.  **Existing Proposal Resumption (Frontend):**
    - User selects an existing proposal (e.g., from a list fetched from the Express backend).
    - The frontend retrieves the associated `(rfpId, application_generated_thread_id)`.
    - Frontend interacts with the LangGraph server (port 2024), passing this `application_generated_thread_id` in `configurable: { thread_id: ... }`.
4.  **Express Backend (Port 3001):**
    - Provides API endpoints to record new `(user_id, rfp_id, app_generated_thread_id, proposal_title)` associations.
    - Provides API endpoints to list these associations for a user (e.g., for a proposal history sidebar).
    - It does **not** directly manage or initialize the checkpointer for the main LangGraph flow on port 2024.

**Relevant Files (Illustrative):**

- `threads-setup.md`: This plan document.
- `apps/backend/lib/persistence/robust-checkpointer.ts` (or similar e.g. `apps/backend/lib/persistence/singleton-checkpointer.ts`): Implements the singleton checkpointer factory (`getInitializedCheckpointer`).
- `apps/backend/agents/proposal-generation/graph.ts`: Its `createProposalGenerationGraph` function will use `getInitializedCheckpointer`.
- `apps/backend/api/rfp/proposalThreads.ts`: Express API routes for managing proposal thread associations.
- `apps/backend/services/proposalThreadAssociation.service.ts`: Backend service for DB interactions related to associations.
- `apps/web/src/lib/utils/idGenerators.ts` (New or existing): For frontend UUID generation.
- `apps/web/src/features/chat-ui/providers/StreamProvider.tsx` (or similar): Frontend SDK integration point.
- `apps/web/src/features/chat-ui/hooks/useProposalLifecycle.ts` (New or existing): Frontend hook to manage new proposal creation, ID generation, and association.
- `langgraph.json`: LangGraph server configuration, points to `createProposalGenerationGraph`.

---

## Phase 1: Backend - Application Association Layer (Express Server - Port 3001)

_(This phase remains largely unchanged as it deals with application-level data, not the LangGraph server's checkpointer initialization.)_

### Step 1.1: Define Database Table: `user_rfp_proposal_threads`

- **Status:** Design / To Be Implemented
- **Action:** Create/ensure table in Supabase.
- **Schema:**
  - `id` (UUID, Primary Key - for the association record itself)
  - `user_id` (TEXT, not null, indexed)
  - `rfp_id` (TEXT, not null, indexed)
  - `app_generated_thread_id` (TEXT, not null, **unique**, indexed - stores the UUID generated by the frontend)
  - `proposal_title` (TEXT, nullable - user-friendly title for the proposal instance)
  - `created_at` (TIMESTAMPTZ, default `now()`)
  - `updated_at` (TIMESTAMPTZ, default `now()`)
- **Indexes:** PK on `id`, Unique on `app_generated_thread_id`, Index on `(user_id, rfp_id)`, Index on `user_id`.

### Step 1.2: Create Service: `ProposalThreadAssociationService`

- **Status:** To Be Implemented
- **File:** `apps/backend/services/proposalThreadAssociation.service.ts`
- **Methods:**
  1.  `async recordNewProposalThread(data: { userId: string, rfpId: string, appGeneratedThreadId: string, proposalTitle?: string }): Promise<{ associationId: string, newRecord: boolean }>`
      - Inputs: `userId`, `rfpId`, `appGeneratedThreadId` (from frontend), `proposalTitle`.
      - Action: Inserts into `user_rfp_proposal_threads`.
      - Handles potential unique constraint violation on `appGeneratedThreadId`. If it exists and `userId`/`rfpId` match, return existing `associationId` and `newRecord: false`. Otherwise, if `appGeneratedThreadId` is linked to different user/RFP, this is an error condition to handle (should be rare with UUIDs but good for robustness).
      - Returns `{ associationId, newRecord: true }` on successful new insert.
  2.  `async listUserProposalThreads(userId: string, rfpId?: string): Promise<Array<UserProposalThreadType>>` (Define `UserProposalThreadType` with relevant fields like `rfpId`, `appGeneratedThreadId`, `proposalTitle`, `createdAt`, `updatedAt`)
      - Queries `user_rfp_proposal_threads` for `userId`, optionally filters by `rfpId`.
      - Orders by `updated_at DESC`.

### Step 1.3: Create API Endpoint: Record New Proposal Thread Association

- **Status:** To Be Implemented
- **Route:** `POST /api/rfp/proposal_threads`
- **File:** `apps/backend/api/rfp/proposalThreads.ts`
- **Request Body:** `{ rfpId: string, appGeneratedThreadId: string, proposalTitle?: string }`
- **Logic:** Auth user, validate body, call `service.recordNewProposalThread`, respond with success/failure and `associationId`.

### Step 1.4: Create API Endpoint: List User's Proposal Threads

- **Status:** To Be Implemented
- **Route:** `GET /api/rfp/proposal_threads`
- **File:** `apps/backend/api/rfp/proposalThreads.ts`
- **Query:** `?rfpId=<string>` (optional)
- **Logic:** Auth user, get `rfpId` from query, call `service.listUserProposalThreads`, respond with list.

---

## Phase 2: Frontend - `thread_id` Generation, Orchestration & SDK Interaction

_(This phase remains largely unchanged, focusing on the frontend's responsibilities.)_

### Step 2.1: Environment Configuration

- **Status:** Verify
- **Files:** Frontend `.env` files.
- **Content:**
  - `NEXT_PUBLIC_LANGGRAPH_API_URL="http://localhost:2024"`
  - `NEXT_PUBLIC_API_URL="http://localhost:3001"`

### Step 2.2: UUID Generation Utility

- **Status:** To Be Implemented/Ensured
- **Action:** Add `uuid` package if not already present (`npm install uuid && npm install --save-dev @types/uuid`). Create or use a utility function, e.g., in `apps/web/src/lib/utils/idGenerators.ts`, to provide `generateUUID(): string` (which calls `uuidv4()`).

### Step 2.3: Implement "Start New Proposal" Flow (User Scenario 3)

- **Status:** To Be Implemented
- **Location:** Frontend logic (e.g., a React hook `useProposalLifecycle.ts` or page component).
- **Trigger:** User has selected an `rfpId` and clicks "Start New Proposal".
- **Detailed Flow:**
  1.  **Generate `thread_id`:**
      - `const newAppGeneratedThreadId = generateUUID();`
  2.  **Record Association with Backend:**
      - Make `POST` request to `http://localhost:3001/api/rfp/proposal_threads` with body:
        `{ rfpId: currentRfpId, appGeneratedThreadId: newAppGeneratedThreadId, proposalTitle: "Proposal for [RFP Name/ID] - [Timestamp or Count]" /* Or allow user input */ }`.
      - Await successful response. If this API call fails, do not proceed to LangGraph to avoid orphaned threads. Handle error (e.g., notify user).
  3.  **Update Frontend State:**
      - Set `activeRfpId = currentRfpId`.
      - Set `activeThreadId = newAppGeneratedThreadId` (this state variable will be used by SDK).
  4.  **Initiate LangGraph Interaction:**
      - The application can now navigate to the chat UI or initialize the LangGraph SDK components.
      - The first SDK call (e.g., `client.streamEvents()` or `graph.invoke()`) that requires persistence **must** include this ID:
        `{ configurable: { thread_id: newAppGeneratedThreadId } }`.
      - Example initial input to graph: `{ messages: [new HumanMessage("Start proposal generation for RFP: " + currentRfpId)] }`.

### Step 2.4: Implement "Continue/Select Existing Proposal" Flow (Scenarios 1 & 2)

- **Status:** To Be Implemented
- **Logic:**
  - **Dashboard/Direct Link (Scenario 1):** `rfpId` and `app_generated_thread_id` are known. Set these in frontend state (`activeRfpId`, `activeThreadId`).
  - **Sidebar Selection (Scenario 2):**
    - Fetch list from `GET http://localhost:3001/api/rfp/proposal_threads`.
    - User clicks an item, its `rfpId` and `app_generated_thread_id` are used to set `activeRfpId` and `activeThreadId`.
  - **For both:** The chat interface loads/updates, and subsequent SDK calls use the `activeThreadId`.

### Step 2.5: LangGraph SDK Integration (e.g., `StreamProvider.tsx`)

- **Status:** Refine
- **Action:** Ensure all LangGraph SDK interactions (e.g., `streamEvents`, `invoke`, `getState`, `updateState`) that need to be part of a persistent thread correctly use the `activeThreadId` from the frontend state by passing it in the `configurable` object:
  `{ configurable: { thread_id: activeThreadId } }`.
  These calls should target `NEXT_PUBLIC_LANGGRAPH_API_URL` (Port 2024).

---

## Phase 3: LangGraph Server Configuration & Singleton Checkpointer (Port 2024)

### Step 3.1: Implement Singleton Checkpointer Factory

- **Status:** To Be Implemented / Refined
- **File:** `apps/backend/lib/persistence/robust-checkpointer.ts` (or a new file like `singleton-checkpointer.ts`)
- **Action:** Implement or refine the checkpointer factory function (e.g., `getInitializedCheckpointer()`) based on the robust singleton pattern discussed. This factory will:
  - Maintain module-scoped (private) variables for a single `pg.Pool` instance, a single `PostgresSaver` instance, and a boolean flag `isSetupComplete`.
  - On its first successful execution path for `PostgresSaver`:
    - Create the `pg.Pool` once.
    - Instantiate `PostgresSaver` with this pool once.
    - Call `await postgresSaverInstance.setup()` **exactly once**.
    - Set `isSetupComplete = true`.
  - On subsequent calls, if already initialized, return the existing `PostgresSaver` instance.
  - Include robust error handling and fallback to `MemorySaver` if PostgreSQL connection or setup fails, setting `isSetupComplete = true` for the `MemorySaver` path as well.
- **Reference:** The refined code snippet discussed previously that handles singleton creation and one-time setup.

### Step 3.2: Utilize Singleton Checkpointer in Graph Compilation

- **Status:** To Be Implemented / Refined
- **File:** `apps/backend/agents/proposal-generation/graph.ts`
- **Action:** Modify the `createProposalGenerationGraph()` function.

  - Instead of directly calling the older `createRobustCheckpointer()` or `createCheckpointer()` from `checkpointer.service.ts` in a way that might re-initialize, it **must** call the new singleton factory function (e.g., `await getInitializedCheckpointer()`) from Step 3.1.

    ```typescript
    // Inside createProposalGenerationGraph() in graph.ts
    // import { getInitializedCheckpointer } from "../../lib/persistence/singleton-checkpointer.js"; // Or similar path

    async function createProposalGenerationGraph() {
      // ... other setup ...
      const checkpointer = await getInitializedCheckpointer(); // Ensures singleton and one-time setup

      // ... existing graph definition (proposalGenerationGraph.addNode, .addEdge, etc.) ...

      const compiledGraph = proposalGenerationGraph.compile({
        checkpointer,
      });

      return compiledGraph;
    }
    ```

- **Rationale:** The `langgraph.json` file points to `createProposalGenerationGraph` for the `langgraph-cli` server. This change ensures that when the LangGraph server (port 2024) starts and compiles this graph, it uses a checkpointer that has had its `setup()` method called correctly and only once.

### Step 3.3: Verify `langgraph.json` Configuration

- **Status:** Verify
- **File:** `langgraph.json`
- **Action:** Ensure it correctly points to the `createProposalGenerationGraph` function within `apps/backend/agents/proposal-generation/graph.ts`. This is the entry point for the LangGraph server to load and compile the graph.

### Step 3.4: Re-evaluate `apps/backend/services/checkpointer.service.ts`

- **Status:** Review / Potentially Deprecate
- **Action:**
  - The primary checkpointer for the main proposal graph is now initialized via the singleton factory directly within `createProposalGenerationGraph` (used by the LangGraph server on port 2024).
  - If the Express backend (port 3001) has no other independent need to create or manage checkpointer instances for other graphs or direct checkpoint manipulation, `checkpointer.service.ts` may be redundant for the main flow and could be simplified or removed to avoid confusion.
  - If it _is_ kept for other purposes within the Express backend process, ensure it also uses the _same singleton factory_ (`getInitializedCheckpointer`) to avoid conflicting initializations _if these processes were ever to be merged or share code directly in a way that bypasses inter-process communication_. However, for separate processes, each would get its own singleton instance from the factory.

---

## Phase 4: Testing and Refinement

- **Status:** To Be Implemented
- **Actions:**
  - **Checkpointer Initialization Tests:**
    - Verify that `PostgresSaver.setup()` is called only once even if `getInitializedCheckpointer()` is invoked multiple times by the LangGraph server's graph compilation.
    - Test fallback to `MemorySaver` if DB is unavailable at startup.
    - Confirm idempotency of `getInitializedCheckpointer()`.
  - **Frontend Flow Tests:**
    - Thoroughly test all three user scenarios for thread initiation and resumption (new proposal, continue from dashboard, select from sidebar).
    - Verify `app_generated_thread_id` is correctly generated, stored via the Express backend, and used in SDK calls to the LangGraph server.
  - **Persistence Tests:**
    - Confirm LangGraph checkpoints are created in Postgres with the application-generated `thread_id`.
    - Test data persistence and isolation between different threads for the same user/RFP and across different users.
    - Test ability to create multiple distinct proposals (each with a unique `app_generated_thread_id`) for the same RFP by the same user.
  - Implement comprehensive error handling for API calls (Express backend) and SDK interactions (frontend to LangGraph server).

---

This updated plan integrates the singleton checkpointer strategy, ensuring `setup()` is called once by the LangGraph server, while preserving the application-driven `thread_id` generation and management.
